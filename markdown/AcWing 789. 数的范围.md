[AcWing 789. 数的范围](https://www.acwing.com/problem/content/791/)

#### 题目描述

给定一个按照升序排列的长度为 n 的整数数组，以及 q 个查询。

对于每个查询，返回一个元素 k 的起始位置和终止位置（位置从 00 开始计数）。

如果数组中不存在该元素，则返回 `-1 -1`。

**输入格式**

第一行包含整数 n 和 q，表示数组长度和询问个数。

第二行包含 n 个整数（均在 1∼10000 范围内），表示完整数组。

接下来 q 行，每行包含一个整数 k，表示一个询问元素。

**输出格式**

共 q 行，每行包含两个整数，表示所求元素的起始位置和终止位置。

如果数组中不存在该元素，则返回 `-1 -1`。

**数据范围**

1≤n≤100000
1≤q≤10000
1≤k≤10000

**输入样例**：

```cpp
6 3
1 2 2 3 3 4
3
4
5
```

**输出样例**：

```cpp
3 4
5 5
-1 -1
```

#### C++

```cpp
#include <iostream>

using namespace std;

const int N = 1e5 + 10;

int main() {
    int n, q;
    int a[N];
    cin >> n >> q;
    for (int i = 0; i < n; i++) cin >> a[i];
    while (q--) {
        int x;
        cin >> x;
        int l = 0, r = n - 1;
        while (l < r) {
            int mid = (l + r) >> 1;
            if (a[mid] >= x) r = mid;
            else l = mid + 1;
        }
        if (a[l] != x) cout << "-1 -1" << endl;
        else {
            cout << l << " ";
            l = 0, r = n - 1;
            while (l < r) {
                int mid = (l + r + 1) >> 1;
                if (a[mid] <= x) l = mid;
                else r = mid - 1;
            }
            cout << l << endl;
        }
    }
}
```

#### Go

```go
package main

import "fmt"

const N = 1e5 + 10

func main() {
	var n, q int
	var a [N]int
	fmt.Scanf("%d%d", &n, &q)
	for i := 0; i < n; i++ {
		fmt.Scanf("%d", &a[i])
	}
	for i := q; i > 0; i-- {
		var x int
		fmt.Scanf("%d", &x)
		l := 0
		r := n - 1
		for l < r {
			mid := (l + r) / 2
			if a[mid] >= x {
				r = mid
			} else {
				l = mid + 1
			}
		}
		if a[l] != x {
			fmt.Println("-1 -1")
		} else {
			fmt.Print(l, " ")
			l = 0
			r = n - 1
			for l < r {
				mid := (l + r + 1) / 2
				if a[mid] <= x {
					l = mid
				} else {
					r = mid - 1
				}
			}
			fmt.Println(l)
		}
	}
}
```

#### 思路

**寻找左边界使用**`q[mid] >= x`的逻辑

当我们使用`q[mid] >= x`条件时，意味着每当中间元素的值大于等于目标值时，我们都将搜索范围的右边界调整为`mid`。这样做的效果是：

1. 如果`q[mid]`等于`x`，那么这个位置可能是`x`的最左侧出现位置，但我们还需要继续向左搜索，以确认是否有更左侧的`x`。因此，我们将右边界调整为`mid`，以缩小搜索范围，继续向左侧寻找。
2. 如果`q[mid]`大于`x`，即使这个值不是我们要找的，它仍然表明`x`（如果存在）必定在`mid`的左侧，因此我们同样需要将右边界调整为`mid`，以排除右侧的非目标区域。

**为何不使用**`q[mid] > x`

如果我们使用`q[mid] > x`来决定是否调整右边界，则当`q[mid]`恰好等于`x`时，我们会继续在右侧半区间搜索，这将错过最左侧的`x`，因为我们没有排除中间元素即使它等于`x`。

**寻找右边界使用**`q[mid] <= x`的逻辑

1. **当`q[mid]`等于`x`时**：即使我们找到了一个`x`，我们仍需要确定这是否是最右侧的`x`。因此，我们将左边界`l`调整为`mid`，而不是结束搜索。这样可以保证如果存在多个`x`，我们最终能找到最右边的一个。搜索继续在当前找到的`x`的右侧进行，因为左边的`x`已经不影响结果了。
2. **当`q[mid]`小于`x`时**：这意味着`mid`及其左侧的所有元素都不可能是我们要找的最右侧的`x`（它们要么是更小的值，要么是`x`但不是最右侧的）。因此，我们需要向右继续搜索，调整左边界为`mid`。

**为何不使用**`q[mid] < x`

使用`q[mid] < x`来调整左边界可能会错过目标值`x`的最右侧位置。当`q[mid]`正好等于`x`时，我们希望继续探索右侧可能存在的更右侧的`x`。如果我们仅在`q[mid]`小于`x`时向右移动，那么就会在找到第一个`x`时停止搜索，从而错过了数组中后续的`x`。

**当寻找左边界时**，`mid`通常计算为`(l + r) >> 1`，即`(l + r) / 2`的下取整。这种方式的目的是在左右边界不断逼近时，能够偏向左侧，确保不会错过最左侧的目标值。特别是当`l`和`r`相邻时，这种计算方法能保证`mid`等于`l`，避免跳过搜索范围内的最左侧元素。

- **防止无限循环**：使用`(l + r) >> 1`在更新右边界`r = mid`时，由于取整的方式，可以保证`r`向左移动，这避免了在特定条件下可能发生的无限循环。

**寻找右边界时**，`mid`计算为`(l + r + 1) >> 1`，即`(l + r + 1) / 2`的下取整。这里加1的目的是为了在计算中点时向上取整，当`l`和`r`相邻时，能够让`mid`等于`r`，确保搜索范围向右移动，从而能够覆盖到最右侧的目标值。

- **防止无限循环**：在更新左边界`l = mid`时，由于向上取整，可以保证`l`向右移动，这同样避免了可能的无限循环。特别是在`l`和`r`非常接近时，如果仍然使用`(l + r) >> 1`作为`mid`的计算方式，则可能导致`l`无法向右逼近，从而陷入无限循环。

#### 模板

```cpp
bool check(int x) {/* ... */} // 检查x是否满足某种性质

// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：
int bsearch_1(int l, int r)
{
    while (l < r)
    {
        int mid = l + r >> 1;
        if (check(mid)) r = mid;    // check()判断mid是否满足性质
        else l = mid + 1;
    }
    return l;
}
// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：
int bsearch_2(int l, int r)
{
    while (l < r)
    {
        int mid = l + r + 1 >> 1;
        if (check(mid)) l = mid;
        else r = mid - 1;
    }
    return l;
}
```

